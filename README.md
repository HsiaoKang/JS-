# 《JavaScript设计模式和开发实践》 阅读笔记

## 第一章 面向对象的JavaScript

### 语言类型

#### 静态类型语言

在编译时确定变量类型（编译时发现类型问题，增加定义类型的代码）

#### 动态类型语言

在程序运行时，某个变量被赋予某 个 值 之 后， 才 会 具 有 某 种 类 型。（代码数量更少，无法保证变量类型）

#### 鸭子类型

关注对象是否具有所需的特性，而不关心是否是某个类型。这样可以更轻松地额实现__面向接口编程__，而不是面向现实编程。比如一个对象具有`pop`，`push`的实现，那么就可以当作__栈__来使用。

### 多态

思想：将不变的事物和可能改变的事物分离开，书中举例是鸭子和鸡发出叫声的一个事件。将”叫“抽离成不可变的，将“怎么叫（叫声）“抽离成可能改变的部分。公共的部分之去调用这个行为就是，这个行为具体做什么则是在各自不同的部分去设定（将过程化的条件分支转换成对象的多态性，从而消除这些条件分支语句）。

现实举例：在拍摄现场，导演喊“action！”，主 角 开 始 背 台 词， 照 明 师 负 责 打 灯 光， 后 面 的 群 众 演 员 假 装 中 枪 倒 地， 道 具 师 往 镜 头 里 撒 上 雪 花。 在 得 到 同 一 个 消 息 时， 每 个 对 象 都 知 道 自 己 应 该 做 什么。 如 果 不 利 用 对 象 的 多 态 性， 而 是 用 面 向 过 程 的 方 式 来 编 写 这 一 段 代 码， 那 么 相 当 于 在 电 影 开 始 拍 摄 之 后， 导 演 每 次 都 要 走 到 每 个 人 的 面 前， 确 认 它 们 的 职 业 分 工（ 类 型）， 然 后 告 诉 他 们 要 做 什 么。

### 封装

封装是将信息隐藏，包括**数据**、**实现**、**类型**、**变化**，同时不让外界访问到并去存取的手段，目的是提供简介的API，提高安全性。

### 原型模式

 如 果 我 们 想 要 创 建 一 个 对 象， 一 种 方 法 是 先 指 定 它 的 类 型， 然 后 通 过 类 来 创 建 这 个 对 象。 

原 型 模 式 选 择 了 另 外 一 种 方 式， 我 们 不 再 关 心 对 象 的 具 体 类 型， 而 是 找 到 一 个 对 象， 然 后 通 过 克 隆 来 创 建 一 个 一 模 一 样 的 对 象。因为在语言层面就提供了`clone`的方法，所以在JavaScript中原型模式也是语言的一种编程范式。

实现重点：通过Object.create 来克隆一个相同的实例。

注意：create出来的对象在没有自身的属性时，是直接引用的原型对象，所以当原型对象改变后，clone对象的属性值也会变化。

过程：创建原型=>创建实例=>克隆实例

JavaScript 的整个对象系统都是建立在原型模式上的，在JavaScript中更多体现的是一种**编程范式**,原型和对象之间存在一种委托关系，对象自身不存在的属性通过原型链委托到原型对象上。

### 总结

这一章的内容其实主要是在描述**面向对象编程**的四种特性__多态性__，__封装性__，__继承性__，__抽象性__。以及在JavaScritpt中__原型模式__的原理和实现。



## 第二章 this、call 和 apply

### this

this总是指向一个上下文对象，具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数声明时的环境。

#### 指向

除去不常用的`with`和`eval`情况，大致分下面四种。

- 作为对象的方法调用（对象）

- 作为普通函数函数调用（window || 严格模式undefined，可以用变量保存this）

- 构造器调用（指向隐式返回的对象）

- Function.prototype.call 和 Function.prototype.apply 调用（改变this指向）

### apply 和 call

第一个参数均是预期指向的目标对象，传`null`则是指向默认的宿主window

后面参数有所不同，`apply`是一个数组格式的集合，`call`是包装`apply`的语法糖，可以明确的表现出形参和实参的对应关系。

除了改变 this 的指向，call 和 apply 还能在目标参数上调用其他其他类型的方法，此时第一个参数传`null`

举例有: 操作arguments的时候，可以考虑使用Array的的方法。

### bind

绑定函数的this指向，且后面无法再次bind